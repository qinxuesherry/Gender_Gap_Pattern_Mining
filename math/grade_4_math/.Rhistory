library(dtwclust)
library(dtw)
df<-read.csv("gap_list_year.csv")
df
df <- subset(df, select = -c(X) )
df
colnames(df)[colnames(df) == "X2000"] = "2000"
colnames(df)[colnames(df) == "X2003"] = "2003"
colnames(df)[colnames(df) == "X2005"] = "2005"
colnames(df)[colnames(df) == "X2007"] = "2007"
colnames(df)[colnames(df) == "X2009"] = "2009"
colnames(df)[colnames(df) == "X2011"] = "2011"
colnames(df)[colnames(df) == "X2013"] = "2013"
colnames(df)[colnames(df) == "X2015"] = "2015"
colnames(df)[colnames(df) == "X2017"] = "2017"
colnames(df)[colnames(df) == "X2019"] = "2019"
colnames(df)[colnames(df) == "X2022"] = "2022"
df
jurisdiction = df[['Jurisdiction']]
dtw_df <- df[, -1]
df
dtw_df
df_lst <- tslist(dtw_df)
remove_nan <- function(ts) {
ts[!is.na(ts)]
}
# Apply the function to each time series in the list
df_lst <- lapply(df_lst, remove_nan)
df_lst
df_cvi <- list()
for (i in 2:10){
df_clust <- tsclust(df_lst, type = "partitional", k = i, distance = "dtw_basic", centroid = "pam")
df_metric <- cvi(df_clust, type = "valid", log.base = 10)
df_cvi <- append(df_cvi, list(df_metric))
}
df_cvi_ma <- do.call(rbind, df_cvi)
rw <- c("K2","K3","K4","K5","K6","K7","K8","K9","K10")
rownames(df_cvi_ma) <- rw
print(df_cvi_ma)
#k2
df_clust_opt <- tsclust(df_lst, type = "partitional", k = 2, distance = "dtw", centroid = "pam",seed = 725)
plot(df_clust_opt)
#k7
df_clust_opt2 <- tsclust(df_lst, type = "partitional", k = 7, distance = "dtw", centroid = "pam",seed = 725)
plot(df_clust_opt2)
#k9
df_clust_opt3 <- tsclust(df_lst, type = "partitional", k = 9, distance = "dtw", centroid = "pam",seed = 725)
plot(df_clust_opt3)
#k4
df_clust_opt_4 <- tsclust(df_lst, type = "partitional", k = 4, distance = "dtw", centroid = "pam",seed = 725)
plot(df_clust_opt_4)
#k6
df_clust_opt_6 <- tsclust(df_lst, type = "partitional", k = 6, distance = "dtw", centroid = "pam",seed = 725)
plot(df_clust_opt_6)
# Extract cluster assignments
cluster_assignments <- df_clust_opt@cluster
# Unique clusters
clusters <- unique(cluster_assignments)
# Colors for each cluster
colors <- rainbow(length(clusters))
# Plot each time series with color based on cluster assignment
plot(NULL, xlim = c(1, ncol(dtw_df)), ylim = range(dtw_df), xlab = "Time", ylab = "Value", type = "n")
for(i in 1:nrow(dtw_df)) {
ts_color <- colors[cluster_assignments[i]]
lines(dtw_df[i, ], col = ts_color)
}
# Add a legend
legend("topright", legend = jurisdiction, col = colors[cluster_assignments], lty = 1)
# Extract cluster assignments
cluster_assignments <- df_clust_opt@cluster
# Determine the number of clusters
num_clusters <- max(cluster_assignments)
# Loop through each cluster and print the jurisdictions in it
for (cluster_number in 1:num_clusters) {
cat("Jurisdictions in Cluster", cluster_number, ":\n")
# Find the indices of jurisdictions in this cluster
indices_in_cluster <- which(cluster_assignments == cluster_number)
# Print the jurisdictions corresponding to these indices
print(jurisdiction[indices_in_cluster])
cat("\n") # Add a newline for readability
}
# Extract cluster assignments
cluster_assignments <- df_clust_opt_4@cluster
# Determine the number of clusters
num_clusters <- max(cluster_assignments)
# Loop through each cluster and print the jurisdictions in it
for (cluster_number in 1:num_clusters) {
cat("Jurisdictions in Cluster", cluster_number, ":\n")
# Find the indices of jurisdictions in this cluster
indices_in_cluster <- which(cluster_assignments == cluster_number)
# Print the jurisdictions corresponding to these indices
print(jurisdiction[indices_in_cluster])
cat("\n") # Add a newline for readability
}
plot(NULL, xlim = c(1, ncol(dtw_df)), ylim = range(dtw_df), xlab = "Time", ylab = "Value", type = "n")
for(i in 1:nrow(dtw_df)) {
# Choose a color based on cluster assignment for visibility
ts_color <- colors[cluster_assignments[i]]
# Plot each time series line
lines(dtw_df[i, ], col = ts_color)
# Annotate the end of each line with the jurisdiction name
# Adjust the position as necessary
text(ncol(dtw_df), dtw_df[i, ncol(dtw_df)], labels = jurisdiction[i], col = ts_color, cex = 0.6, pos = 4)
}
library(ggplot2)
# Determine the number of clusters
num_clusters <- max(cluster_assignments)
# Prepare the data for ggplot
dtw_df_long <- reshape2::melt(dtw_df)
dtw_df_long$Jurisdiction <- rep(jurisdiction, each = ncol(dtw_df))
# Loop through each cluster
for (cluster_number in 1:num_clusters) {
# Find the indices of jurisdictions in this cluster
indices_in_cluster <- which(cluster_assignments == cluster_number)
# Filter the data for the current cluster
data_for_cluster <- dtw_df_long[dtw_df_long$Jurisdiction %in% jurisdiction[indices_in_cluster], ]
# Plot
ggplot(data_for_cluster, aes(x = variable, y = value, group = Jurisdiction, color = Jurisdiction)) +
geom_line() +
theme(legend.position = "bottom") +
ggtitle(paste("Cluster", cluster_number)) +
xlab("Time") + ylab("Value")
# Display the plot
print(g)
}
library(ggplot2)
# Loop through each cluster to create a plot for each
for (cluster_number in 1:num_clusters) {
# Find the indices of jurisdictions in this cluster
indices_in_cluster <- which(cluster_assignments == cluster_number)
# Subset the data frame for only the jurisdictions in this cluster
dtw_df_subset <- dtw_df[indices_in_cluster, ]
jurisdictions_subset <- jurisdiction[indices_in_cluster]
# Convert the subset data frame to long format for ggplot2
long_df <- reshape2::melt(dtw_df_subset, variable.name = "Time", value.name = "Value")
long_df$Jurisdiction <- rep(jurisdictions_subset, each = ncol(dtw_df_subset))
# Create the plot for the current cluster
ggplot(long_df, aes(x = Time, y = Value, group = Jurisdiction, color = Jurisdiction)) +
geom_line() +
theme_minimal() +
ggtitle(paste("Cluster", cluster_number)) +
theme(legend.position = "right") +
labs(color = "Jurisdiction")
# Display the plot
print(last_plot())
# Optionally, save the plot to a file
ggsave(paste("Cluster_", cluster_number, ".png", sep = ""), plot = last_plot(), width = 10, height = 6)
}
# Load necessary libraries
library(ggplot2)
library(reshape2)
# Loop through each cluster
for (cluster_number in 1:num_clusters) {
# Find the indices of jurisdictions in this cluster
indices_in_cluster <- which(cluster_assignments == cluster_number)
# Subset the df for only those jurisdictions in the current cluster
cluster_df <- dtw_df[indices_in_cluster, ]
# Convert the data to long format for ggplot
long_df <- melt(cluster_df, variable.name = "Year", value.name = "Value")
long_df$Jurisdiction <- rep(jurisdiction[indices_in_cluster], each = ncol(cluster_df))
# Plot
ggplot(long_df, aes(x = Year, y = Value, group = Jurisdiction, color = Jurisdiction)) +
geom_line() +
labs(title = paste("Cluster", cluster_number), x = "Year", y = "Value") +
theme(legend.position = "right") +
guides(color = guide_legend(override.aes = list(size=3)))
# Pause between plots
readline(prompt="Press [enter] to continue")
}
# Load the data
gap_list <- read.csv("gap_list.csv")
# Check the structure of the data
str(gap_list)
# Load necessary libraries
library(ggplot2)
library(reshape2)
# Loop through each cluster
for (cluster_number in 1:num_clusters) {
cat("Plotting jurisdictions in Cluster", cluster_number, ":\n")
# Find the indices of jurisdictions in this cluster
indices_in_cluster <- which(cluster_assignments == cluster_number)
# Get the names of the jurisdictions in this cluster
jurisdictions_in_cluster <- jurisdiction[indices_in_cluster]
# Filter the gap_list data frame for these jurisdictions
cluster_data <- gap_list[gap_list$Jurisdiction %in% jurisdictions_in_cluster, ]
# Convert the data to long format for ggplot
long_df <- melt(cluster_data, id.vars = "Jurisdiction", variable.name = "Year", value.name = "Value")
# Plot
p <- ggplot(long_df, aes(x = Year, y = Value, group = Jurisdiction, color = Jurisdiction)) +
geom_line() +
labs(title = paste("Cluster", cluster_number), x = "Year", y = "Value") +
theme(legend.position = "right")
print(p)
# Optional: Save the plot to a file
# ggsave(paste("cluster_", cluster_number, ".png", sep=""), plot = p)
}
gap_list_year <- read.csv("gap_list_year.csv")
# Load necessary libraries
library(ggplot2)
library(reshape2)
# Loop through each cluster
for (cluster_number in 1:num_clusters) {
cat("Plotting jurisdictions in Cluster", cluster_number, ":\n")
# Find the indices of jurisdictions in this cluster
indices_in_cluster <- which(cluster_assignments == cluster_number)
# Get the names of the jurisdictions in this cluster
jurisdictions_in_cluster <- jurisdiction[indices_in_cluster]
# Filter the gap_list_year data frame for these jurisdictions
cluster_data <- gap_list_year[gap_list_year$Jurisdiction %in% jurisdictions_in_cluster, ]
# Convert the data to long format for ggplot
long_df <- melt(cluster_data, id.vars = "Jurisdiction", variable.name = "Year", value.name = "Value")
# Plot
p <- ggplot(long_df, aes(x = Year, y = Value, group = Jurisdiction, color = Jurisdiction)) +
geom_line() +
labs(title = paste("Cluster", cluster_number), x = "Year", y = "Value") +
theme(legend.position = "right")
print(p)
# Optional: Pause between plots if running interactively
# readline(prompt="Press [enter] to continue")
# Optional: Save the plot to a file
# ggsave(paste("cluster_", cluster_number, ".png", sep=""), plot = p)
}
